import z from "zod";
import { clickhouseClient } from "./common";

// The fully-qualified rows in a dataset
export const ChatInferenceDatasetRowSchema = z
  .object({
    dataset_name: z.string(),
    function_name: z.string(),
    id: z.string().uuid(),
    episode_id: z.string().uuid(),
    input: z.string(),
    output: z.string().optional(),
    tool_params: z.string(),
    tags: z.record(z.string(), z.string()),
    auxiliary: z.string(),
    is_deleted: z.boolean().default(false),
    created_at: z.string().datetime().default(new Date().toISOString()),
  })
  .strict();
export type ChatInferenceDatasetRow = z.infer<
  typeof ChatInferenceDatasetRowSchema
>;

export const JsonInferenceDatasetRowSchema = z
  .object({
    dataset_name: z.string(),
    function_name: z.string(),
    id: z.string().uuid(),
    episode_id: z.string().uuid(),
    input: z.string(),
    output: z.string().optional(),
    output_schema: z.string(),
    tags: z.record(z.string(), z.string()),
    auxiliary: z.string(),
    is_deleted: z.boolean().default(false),
    created_at: z.string().datetime(),
  })
  .strict();
export type JsonInferenceDatasetRow = z.infer<
  typeof JsonInferenceDatasetRowSchema
>;

export const DatasetRowSchema = z.union([
  ChatInferenceDatasetRowSchema,
  JsonInferenceDatasetRowSchema,
]);
export type DatasetRow = z.infer<typeof DatasetRowSchema>;

// The types that correspond to inserts into the dataset.
// Since is_deleted and created_at are generated by the database, we don't include them in the insert types.

export const ChatInferenceDatasetInsertSchema =
  ChatInferenceDatasetRowSchema.omit({
    is_deleted: true,
    created_at: true,
  });
export type ChatInferenceDatasetInsert = z.infer<
  typeof ChatInferenceDatasetInsertSchema
>;

export const JsonInferenceDatasetInsertSchema =
  JsonInferenceDatasetRowSchema.omit({
    is_deleted: true,
    created_at: true,
  });
export type JsonInferenceDatasetInsert = z.infer<
  typeof JsonInferenceDatasetInsertSchema
>;

export const DatasetInsertSchema = z.union([
  ChatInferenceDatasetInsertSchema,
  JsonInferenceDatasetInsertSchema,
]);
export type DatasetInsert = z.infer<typeof DatasetInsertSchema>;

export const DatasetQueryParamsSchema = z.object({
  inferenceType: z.enum(["chat", "json"]),
  function_name: z.string().optional(),
  variant_name: z.string().optional(), // We will 400 if there's a variant_name but no function_name
  extra_where: z.string().array().default([]), // Extra WHERE clauses, e.g. ["episode_id = {episode_id:UUID}", "variant_name = {variant:String}"]
  extra_params: z
    .record(z.string(), z.union([z.string(), z.number()]))
    .default({}), // Extra query parameters, mapping placeholders (like "episode_id") => actual values
  metric_filter: z
    .object({
      metric: z.string(),
      metric_type: z.enum(["boolean", "float"]),
      operator: z.enum([">", "<"]),
      threshold: z.number(),
      join_on: z.enum(["inference_id", "episode_id"]),
    })
    .optional(),
  join_demonstrations: z.boolean().optional(),
  include_output: z.boolean().optional(), // Whether to include the output from the original inference in the response
  limit: z.number().optional(),
  offset: z.number().optional(),
});
export type DatasetQueryParams = z.infer<typeof DatasetQueryParamsSchema>;

/**
 * buildDatasetSelectQuery constructs a SELECT query for either the Chat or JSON
 * dataset table. It builds a list of fields to select, applies filtering conditions
 * (e.g. function_name, variant_name, extra WHERE clauses, reward filters), and
 * applies LIMIT/OFFSET if provided.
 *
 * If includeOutput is false, the output field is replaced with a NULL value.
 * If joinDemonstrations is false (or not true), the auxiliary field is set to an empty string.
 */
function buildDatasetSelectQuery(params: DatasetQueryParams): {
  query: string;
  query_params: Record<string, string | number>;
} {
  const {
    inferenceType,
    function_name,
    variant_name,
    extra_where,
    extra_params,
    metric_filter,
    join_demonstrations: joinDemonstrations,
    include_output: includeOutput,
    limit,
    offset,
  } = params;

  // Ensure that if a variant_name is provided, function_name must also be provided.
  if (variant_name && !function_name) {
    throw new Error(
      "If variant_name is provided, function_name must also be provided.",
    );
  }

  // Choose the correct table name based on the inference type.
  const tableName =
    inferenceType === "chat" ? "ChatInference" : "JsonInference";

  // Build the list of fields to select.
  let selectFields: string[];
  if (inferenceType === "chat") {
    selectFields = [
      "function_name",
      "id",
      "episode_id",
      "input",
      "output",
      "tool_params",
      "tags",
    ];
  } else {
    selectFields = [
      "function_name",
      "id",
      "episode_id",
      "input",
      "output",
      "output_schema",
      "tags",
    ];
  }

  // If includeOutput is false, replace the output field with NULL.
  if (includeOutput === false) {
    selectFields = selectFields.map((field) =>
      field === "output" ? "NULL AS output" : field,
    );
  }

  // For now, the auxiliary field is always an empty string.
  selectFields.push("'' AS auxiliary");

  // Start constructing the query.
  let query = `SELECT ${selectFields.join(", ")} FROM ${tableName}`;

  // Build WHERE clauses.
  const whereClauses: string[] = [];
  const queryParams: Record<string, string | number> = {};

  // Merge any extra_params passed in.
  if (extra_params) {
    Object.assign(queryParams, extra_params);
  }

  if (function_name) {
    whereClauses.push("function_name = {function_name:String}");
    queryParams.function_name = function_name;
  }

  if (variant_name) {
    whereClauses.push("variant_name = {variant_name:String}");
    queryParams.variant_name = variant_name;
  }

  // Metric filter join logic
  if (metric_filter) {
    // Determine the join key
    const join_column = getFeedbackJoinColumn(metric_filter.join_on);
    // Choose the correct feedback table.
    const feedback_table = getFeedbackTable(metric_filter.metric_type);
    const reward_condition = `AND value ${metric_filter.operator} {metric_threshold:Float}`;
    // Add the join clause.
    query += ` JOIN (
      SELECT
        target_id,
        value,
        ROW_NUMBER() OVER (PARTITION BY target_id ORDER BY timestamp DESC) as rn
        FROM ${feedback_table}
        WHERE metric_name = {metric_name:String}
        ${reward_condition}
    ) AS feedback ON ${tableName}.${join_column} = feedback.target_id AND feedback.rn = 1`;
    // Set the query parameters for feedback filtering.
    queryParams.metric_name = metric_filter.metric;
    queryParams.metric_threshold = metric_filter.threshold;
  }

  // Append any extra WHERE clauses.
  if (extra_where && extra_where.length > 0) {
    whereClauses.push(...extra_where);
  }

  if (whereClauses.length > 0) {
    query += " WHERE " + whereClauses.join(" AND ");
  }

  // Append LIMIT and OFFSET if provided.
  if (limit !== undefined) {
    query += " LIMIT {limit:UInt32}";
    queryParams.limit = limit;
  }
  if (offset !== undefined) {
    query += " OFFSET {offset:UInt32}";
    queryParams.offset = offset;
  }

  return { query, query_params: queryParams };
}

export async function selectRowsForDataset(
  params: DatasetQueryParams,
): Promise<DatasetInsert[]> {
  const { query, query_params } = buildDatasetSelectQuery(params);
  const resultSet = await clickhouseClient.query({
    query,
    format: "JSONEachRow",
    query_params,
  });
  const rows = await resultSet.json<DatasetInsert[]>();
  return z.array(DatasetInsertSchema).parse(rows);
}

/// Counts the number of rows in the dataset that match the query parameters.
/// This function does not support the limit or offset parameters.
export async function countRowsForDataset(
  params: DatasetQueryParams,
): Promise<number> {
  // Ensure that limit and offset are not provided.
  if (params.limit !== undefined || params.offset !== undefined) {
    throw new Error(
      "limit and offset are not supported for countRowsForDataset",
    );
  }

  const { query, query_params } = buildDatasetSelectQuery(params);
  const count_query = `SELECT toUInt32(count()) as count FROM (${query})`;
  const resultSet = await clickhouseClient.query({
    query: count_query,
    format: "JSONEachRow",
    query_params,
  });
  const rows = await resultSet.json<{ count: number }>();
  return rows[0].count;
}

function getFeedbackJoinColumn(join_on: "inference_id" | "episode_id") {
  return join_on === "inference_id" ? "id" : "episode_id";
}

function getFeedbackTable(metric_type: "boolean" | "float") {
  return metric_type === "boolean"
    ? "BooleanMetricFeedback"
    : "FloatMetricFeedback";
}
